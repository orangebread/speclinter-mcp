import { promises as fs } from 'fs';
import path from 'path';
import crypto from 'crypto';
import { Storage } from './storage.js';
import { DEFAULT_CONFIG } from '../types/config.js';
import { IMSManifest, IMSManifestSchema, validateIMSManifest } from '../types/ims-schemas.js';

/**
 * StorageManager provides auto-initialization capabilities for Storage instances.
 * This avoids circular dependencies and maintains clean architecture by keeping
 * the Storage class as a pure data layer component.
 */
export class StorageManager {
  /**
   * Creates and initializes a Storage instance, automatically setting up
   * the required directory structure if it doesn't exist.
   */
  static async createInitializedStorage(rootDir?: string): Promise<Storage> {
    const storage = new Storage(rootDir);

    try {
      await storage.initialize();
      return storage;
    } catch (error) {
      // Check if the error is due to missing initialization
      if (error instanceof Error && error.message.includes('not initialized')) {
        console.error('SpecLinter not initialized. Auto-initializing with default configuration...');
        await this.autoInitialize(rootDir || process.cwd());

        // Create a fresh Storage instance after auto-initialization
        // This ensures the Storage instance sees the newly created directories
        const freshStorage = new Storage(rootDir);
        await freshStorage.initialize();
        console.error('âœ… SpecLinter auto-initialized successfully!');
        return freshStorage;
      }

      // Re-throw other errors
      throw error;
    }
  }

  /**
   * Performs minimal auto-initialization required for Storage to function.
   * Only creates the essential directory structure and configuration.
   */
  private static async autoInitialize(rootDir: string): Promise<void> {
    const speclinterDir = path.join(rootDir, '.speclinter');
    
    try {
      // Create essential directory structure
      const directories = [
        '.speclinter',
        '.speclinter/context',
        '.speclinter/manifests',
        'speclinter-tasks'
      ];

      for (const dir of directories) {
        const dirPath = path.join(rootDir, dir);
        await fs.mkdir(dirPath, { recursive: true });
      }

      // Create default config if it doesn't exist
      const configPath = path.join(speclinterDir, 'config.json');
      try {
        await fs.access(configPath);
        // Config already exists, don't overwrite
      } catch {
        // Config doesn't exist, create it
        await fs.writeFile(
          configPath,
          JSON.stringify(DEFAULT_CONFIG, null, 2)
        );
      }

      // Create context directory (files will be AI-generated on first analysis)
      await fs.mkdir(path.join(speclinterDir, 'context'), { recursive: true });

      // Create .gitignore for speclinter if it doesn't exist
      const gitignorePath = path.join(speclinterDir, '.gitignore');
      try {
        await fs.access(gitignorePath);
        // .gitignore already exists, don't overwrite
      } catch {
        // .gitignore doesn't exist, create it
        await fs.writeFile(gitignorePath, '*.db\n*.db-journal\n');
      }

    } catch (error) {
      throw new Error(
        `Failed to auto-initialize SpecLinter: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  // Template creation removed in Option A implementation
  // Context files are now generated by AI analysis instead of generic templates

  /**
   * IMS Manifest Management Methods
   */

  /**
   * Creates and initializes the IMS manifest directory structure
   */
  static async initializeIMSStorage(rootDir?: string): Promise<void> {
    const projectRoot = rootDir || process.cwd();
    const manifestsDir = path.join(projectRoot, '.speclinter', 'manifests');

    try {
      // Create manifests directory structure
      const directories = [
        'manifests',
        'manifests/active',
        'manifests/archive',
        'manifests/chains'
      ];

      for (const dir of directories) {
        const dirPath = path.join(projectRoot, '.speclinter', dir);
        await fs.mkdir(dirPath, { recursive: true });
      }

      // Create manifest index file if it doesn't exist
      const indexPath = path.join(manifestsDir, 'index.json');
      try {
        await fs.access(indexPath);
      } catch {
        const initialIndex = {
          version: '1.0.0',
          manifests: [],
          lastUpdated: new Date().toISOString()
        };
        await fs.writeFile(indexPath, JSON.stringify(initialIndex, null, 2));
      }

    } catch (error) {
      throw new Error(
        `Failed to initialize IMS storage: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Saves an IMS manifest to the storage system
   */
  static async saveIMSManifest(
    manifest: IMSManifest,
    rootDir?: string
  ): Promise<{ filePath: string; hash: string }> {
    const projectRoot = rootDir || process.cwd();

    // Ensure IMS storage is initialized
    await this.initializeIMSStorage(projectRoot);

    // Validate manifest
    const validatedManifest = validateIMSManifest(manifest);

    // Generate manifest hash
    const manifestContent = JSON.stringify(validatedManifest, null, 2);
    const hash = crypto.createHash('sha256').update(manifestContent).digest('hex');
    const manifestHash = `sha256:${hash}`;

    // Generate filename: REQ-ID_TIMESTAMP.manifest.json
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${validatedManifest.requirement.id}_${timestamp}.manifest.json`;
    const filePath = path.join(projectRoot, '.speclinter', 'manifests', 'active', filename);

    // Save manifest file
    await fs.writeFile(filePath, manifestContent);

    // Update index
    await this.updateManifestIndex(validatedManifest, filePath, manifestHash, projectRoot);

    return { filePath, hash: manifestHash };
  }

  /**
   * Updates the manifest index with new manifest information
   */
  private static async updateManifestIndex(
    manifest: IMSManifest,
    filePath: string,
    hash: string,
    rootDir: string
  ): Promise<void> {
    const indexPath = path.join(rootDir, '.speclinter', 'manifests', 'index.json');

    let index;
    try {
      const indexContent = await fs.readFile(indexPath, 'utf-8');
      index = JSON.parse(indexContent);
    } catch {
      index = { version: '1.0.0', manifests: [], lastUpdated: new Date().toISOString() };
    }

    // Add manifest to index
    const manifestEntry = {
      requirementId: manifest.requirement.id,
      filePath: path.relative(rootDir, filePath),
      hash,
      agent: manifest.agent,
      status: manifest.implementation.status || 'unknown',
      createdAt: manifest.agent.timestamp || new Date().toISOString(),
      files: manifest.implementation.files.map(f => f.path),
      chainPrevious: manifest.chain?.previous
    };

    // Remove any existing entry for the same requirement
    index.manifests = index.manifests.filter((m: any) => m.requirementId !== manifest.requirement.id);

    // Add new entry
    index.manifests.push(manifestEntry);
    index.lastUpdated = new Date().toISOString();

    // Save updated index
    await fs.writeFile(indexPath, JSON.stringify(index, null, 2));
  }

  /**
   * Loads an IMS manifest by requirement ID
   */
  static async loadIMSManifest(requirementId: string, rootDir?: string): Promise<IMSManifest | null> {
    const projectRoot = rootDir || process.cwd();
    const indexPath = path.join(projectRoot, '.speclinter', 'manifests', 'index.json');

    try {
      const indexContent = await fs.readFile(indexPath, 'utf-8');
      const index = JSON.parse(indexContent);

      const manifestEntry = index.manifests.find((m: any) => m.requirementId === requirementId);
      if (!manifestEntry) return null;

      const manifestPath = path.join(projectRoot, manifestEntry.filePath);
      const manifestContent = await fs.readFile(manifestPath, 'utf-8');
      const manifest = JSON.parse(manifestContent);

      return validateIMSManifest(manifest);
    } catch {
      return null;
    }
  }

  /**
   * Queries IMS manifests based on criteria
   */
  static async queryIMSManifests(
    criteria: {
      requirementId?: string;
      agent?: string;
      status?: string;
      files?: string[];
    },
    rootDir?: string
  ): Promise<IMSManifest[]> {
    const projectRoot = rootDir || process.cwd();
    const indexPath = path.join(projectRoot, '.speclinter', 'manifests', 'index.json');

    try {
      const indexContent = await fs.readFile(indexPath, 'utf-8');
      const index = JSON.parse(indexContent);

      let filteredEntries = index.manifests;

      // Apply filters
      if (criteria.requirementId) {
        filteredEntries = filteredEntries.filter((m: any) =>
          m.requirementId.includes(criteria.requirementId!)
        );
      }

      if (criteria.agent) {
        filteredEntries = filteredEntries.filter((m: any) =>
          m.agent.identifier.includes(criteria.agent!) || m.agent.source.includes(criteria.agent!)
        );
      }

      if (criteria.status) {
        filteredEntries = filteredEntries.filter((m: any) => m.status === criteria.status);
      }

      if (criteria.files && criteria.files.length > 0) {
        filteredEntries = filteredEntries.filter((m: any) =>
          criteria.files!.some(file => m.files.includes(file))
        );
      }

      // Load full manifests
      const manifests: IMSManifest[] = [];
      for (const entry of filteredEntries) {
        try {
          const manifestPath = path.join(projectRoot, entry.filePath);
          const manifestContent = await fs.readFile(manifestPath, 'utf-8');
          const manifest = JSON.parse(manifestContent);
          manifests.push(validateIMSManifest(manifest));
        } catch {
          // Skip invalid manifests
          continue;
        }
      }

      return manifests;
    } catch {
      return [];
    }
  }

  /**
   * Verifies an IMS manifest by recalculating file hashes
   */
  static async verifyIMSManifest(
    requirementId: string,
    rootDir?: string
  ): Promise<{
    valid: boolean;
    errors: string[];
    fileVerification: Array<{ path: string; valid: boolean; expectedHash?: string; actualHash?: string }>;
  }> {
    const projectRoot = rootDir || process.cwd();
    const manifest = await this.loadIMSManifest(requirementId, projectRoot);

    if (!manifest) {
      return {
        valid: false,
        errors: [`Manifest not found for requirement ${requirementId}`],
        fileVerification: []
      };
    }

    const errors: string[] = [];
    const fileVerification: Array<{ path: string; valid: boolean; expectedHash?: string; actualHash?: string }> = [];

    // Verify each file hash
    for (const file of manifest.implementation.files) {
      if (!file.hash) {
        fileVerification.push({ path: file.path, valid: true }); // No hash to verify
        continue;
      }

      try {
        const filePath = path.join(projectRoot, file.path);
        const fileContent = await fs.readFile(filePath, 'utf-8');
        const actualHash = `sha256:${crypto.createHash('sha256').update(fileContent).digest('hex')}`;

        const valid = actualHash === file.hash;
        fileVerification.push({
          path: file.path,
          valid,
          expectedHash: file.hash,
          actualHash
        });

        if (!valid) {
          errors.push(`File ${file.path} hash mismatch: expected ${file.hash}, got ${actualHash}`);
        }
      } catch (error) {
        fileVerification.push({
          path: file.path,
          valid: false,
          expectedHash: file.hash
        });
        errors.push(`File ${file.path} not found or unreadable`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      fileVerification
    };
  }

  /**
   * Archives an IMS manifest (moves from active to archive)
   */
  static async archiveIMSManifest(requirementId: string, rootDir?: string): Promise<boolean> {
    const projectRoot = rootDir || process.cwd();
    const indexPath = path.join(projectRoot, '.speclinter', 'manifests', 'index.json');

    try {
      const indexContent = await fs.readFile(indexPath, 'utf-8');
      const index = JSON.parse(indexContent);

      const manifestEntry = index.manifests.find((m: any) => m.requirementId === requirementId);
      if (!manifestEntry) return false;

      // Move file from active to archive
      const currentPath = path.join(projectRoot, manifestEntry.filePath);
      const filename = path.basename(manifestEntry.filePath);
      const archivePath = path.join(projectRoot, '.speclinter', 'manifests', 'archive', filename);

      await fs.rename(currentPath, archivePath);

      // Update index
      manifestEntry.filePath = path.relative(projectRoot, archivePath);
      manifestEntry.archivedAt = new Date().toISOString();
      index.lastUpdated = new Date().toISOString();

      await fs.writeFile(indexPath, JSON.stringify(index, null, 2));
      return true;
    } catch {
      return false;
    }
  }
}
